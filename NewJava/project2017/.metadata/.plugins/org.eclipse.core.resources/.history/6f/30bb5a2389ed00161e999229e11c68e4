package exerciseTwo;


/*********************************************************************************************
 * File(s): programTwo.java												     				 *
 * Execution:  programThree is the main class containing the main method 					 *
 * 									 														 *
 * *******************************************************************************************
 * A modified msp3 to print out the maximum subsequence product, input elements, first and last 
 * position of the maximum subsequence product using a divide and conquer algorithm and keeping 
 * track of number of positions that where either negative or positive.
 * Time Complexities for this program O(nlogn).
 * */


import java.util.Scanner; 
import java.lang.Math;  

public class programThree {
	static int a[]; 						//Array a
	static int maxProduct;					//Maximum Subsequence product
	static int prodlt, prodrt;				//product at any instance for lEFT and RIGHT
	static int p1; 		    				//p1 reflect the starting boundary of the current subsequence to be evaluated
	static int p2;  						//p2 reflect the ending boundary of the current subsequence to be evaluated
	static int n;							// size of array
	static int m;							// midpoint of the starting and ending boundaries
	static int L, R;						// msp3 for left and right half of the array list
	static int PL, PR;						// Related to msp3 for both left and right based on prodrt and prodlt
	public programThree(){  				// default constructor 
	}


	public static int msp3(int a[], int p1, int p2)  
	{  
		int maxProduct =1;  
		if (p1 == p2)  
		{  
			maxProduct = a[p1];  
		}  
		else  
		{  
			int m = (p1 + p2)/2;  
			int L = msp3(a,p1,m);
			int R = msp3(a,m+1,p2);  
			int prodlt = 1; 
			int prodrt = 1; 
			int PL = 0; 
			int PR = 0;  
			int numNegL = 0; 								// number Of Negatives in the L side of any subsequence
			int numNegR = 0;  								// number Of Negatives in the R side of any subsequence
			int lastPostBefOddNegR =0;  		// The last recorded Position Before Odd Negative in R
			int lastPostBefOddNegL =0;  		// The last recorded Position Before Odd Negative in L
			int lastProdBefOddNegR = 1;  		// The last recorded Product Before Odd Negative in R
			int lastProdBefOddNegL = 1;  		// The last recorded Product Before Odd Negative in L
			int lastProdBefEvenNegL = 1;  		// The last recorded Product Before Even Negative in L
			int lastProdBefEvenNegR = 1;  		// The last recorded Product Before Even Negative in R
			int lastPostBefEvenNegL = 0;  		// The last recorded Position Before Even Negative in L
			int lastPostBefEvenNegR = 0; 		// The last recorded Position Before Even Negative in R 
			for (int i =m; i>=p1; i--) 				   		//for loop for the left side
			{  
				if (a[i]!=0)  
				{prodlt = prodlt * a[i];  
				PL = prodlt;}  
				else  
				{  
					break;  
				}  
				if (a[i]<0)  									//keeps track of number of negative numbers
				{  
					numNegL++;  
					if ((numNegL%2)!=0)  
					{  
						lastPostBefOddNegL = i;  
						lastProdBefOddNegL = PL;  
					}  
					if ((numNegL%2)==0)  
					{  
						lastPostBefEvenNegL = i;  
						lastProdBefEvenNegL = PL;  
					}  
				}  
			}  
			for (int i = m+1; i<=p2; i++)  						//for loop for the left side
			{  
				if (a[i]!=0)  
				{prodrt = prodrt * a[i];  
				PR = prodrt;}  
				else  
				{  
					break;  
				}  
				if (a[i]<0)  
				{  
					numNegR++;  
					if ((numNegR%2)!=0)  
					{  
						lastPostBefOddNegR = i;  
						lastProdBefOddNegR = PR;  
					}  
					if ((numNegR%2)==0)  
					{  
						lastPostBefEvenNegR = i;  
						lastProdBefEvenNegR = PR;  
					}  
				}  
			}  
			if ((numNegL+numNegR)%2==0)  
			{
				maxProduct = Math.max(Math.max(L,R),PL*PR);
			}  
			else  
			{  
				if ((numNegR)%2!=0) 										//all product on left and product up till negative number on right
				{  
					// all possible cases;
					
					int maxStrProd1 =1;  							       // max straddle a product can produce for any of the subsequence(s) 
					int maxStrProd2 =1;  								   // that extend across both side (L & R)
					int maxStrProd3 =1;  
					if (a[lastPostBefEvenNegL]!=0)  
					{ 
						maxStrProd1 = PR*lastProdBefEvenNegL/a[lastPostBefEvenNegL];
					}  
					if (a[lastPostBefOddNegR]!=0)  
					{ 
						maxStrProd2 = PL*lastProdBefOddNegR/a[lastPostBefOddNegR];
					}  
					if (a[lastPostBefEvenNegR]!=0)  
					{  
						maxStrProd3 = PL*lastProdBefEvenNegR/a[lastPostBefEvenNegR];  
					}  
					
					int maxStraddle = Math.max(maxStrProd1, maxStrProd2);  
					int maxStraddle2 = Math.max(maxStraddle,maxStrProd3);  
					maxProduct = Math.max(Math.max(L,R),maxStraddle2);  
				}  
				if ((numNegL)%2!=0)  														//all produce on right and product up till negative number on left
				{  
					// all possible cases;
					int maxStrProd1=1;  
					int maxStrProd2=1;  
					int maxStrProd3=1;  
					if (a[lastPostBefEvenNegR]!=0)  									//cancels out last negative causing negative straddle
					{ maxStrProd1 = PL*lastProdBefEvenNegR/a[lastPostBefEvenNegR];}  
					if (a[lastPostBefOddNegL]!=0)  
					{ maxStrProd2 = PR*lastProdBefOddNegL/a[lastPostBefOddNegL];}  
					if (a[lastPostBefEvenNegR]!=0)  
					{  
						maxStrProd3 = PL*lastProdBefEvenNegR/a[lastPostBefEvenNegR];  
					}  
					int maxStraddle = Math.max(maxStrProd1, maxStrProd2);  
					int maxStraddle2 = Math.max(maxStraddle,maxStrProd3);  
					maxProduct = Math.max(Math.max(L,R),maxStraddle2);  
				}  
			} 
		}  
		return maxProduct;  
	}  

	public static void main(String[] args)
	{
		Scanner input = new Scanner(System.in);
		int n;

		System.out.println("Enter the Array size N:");

		n = input.nextInt();
		int[] a = new int[n+1];

		for (int i=1; i<=n; i++)
		{
			a[i] =input.nextInt(); 

		}

		input.close();

		System.out.println("Input Elements: ");
		System.out.println("*******************************");

		for(int i =1; i<=n; i++)
		{
			System.out.print(a[i]+" ");
		}
		System.out.println("");

		int p1 = 0;  
		int p2 = a.length-1; 

		maxProduct = msp3(a,p1,p2);

		System.out.println("*******************************");
		System.out.println("First position: " + p1);
		System.out.println("*******************************");
		System.out.println("Last  position: " + p2);
		System.out.println("*******************************");
		System.out.println( "Max Product is " + maxProduct);
	}

}